import {TestBed} from '@angular/core/testing';
import {HttpTestingController, provideHttpClientTesting} from '@angular/common/http/testing';
import {provideHttpClient} from '@angular/common/http';
import {ExploitService} from './exploit.service';
import {environment} from '../../../environments/environment';

describe('ExploitService', () => {
  let service: ExploitService;
  let httpMock: HttpTestingController;
  const baseUrl = environment.backendUrl;

  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [
        ExploitService,
        provideHttpClient(),
        provideHttpClientTesting()
      ]
    });

    service = TestBed.inject(ExploitService);
    httpMock = TestBed.inject(HttpTestingController);
  });

  afterEach(() => {
    // Verify that no unmatched requests are outstanding
    httpMock.verify();
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });

  describe('analyzeRepository', () => {
    it('should make GET request to analyze repository endpoint', () => {
      const repoId = 123;
      const mockResponse = {
        status: 'success',
        message: 'Analysis started',
        analysisId: 'abc-123'
      };

      service.analyzeRepository(repoId).subscribe(response => {
        expect(response).toEqual(mockResponse);
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );

      expect(req.request.method).toBe('GET');
      expect(req.request.withCredentials).toBe(true);

      req.flush(mockResponse);
    });

    it('should handle different repository IDs', () => {
      const testIds = [1, 42, 999, 12345];

      testIds.forEach(id => {
        service.analyzeRepository(id).subscribe();

        const req = httpMock.expectOne(
            `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${id}`
        );
        expect(req.request.url).toContain(`repoId=${id}`);
        req.flush({ status: 'success' });
      });
    });

    it('should include credentials in the request', () => {
      const repoId = 456;

      service.analyzeRepository(repoId).subscribe();

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );

      expect(req.request.withCredentials).toBe(true);
      req.flush({});
    });

    it('should handle successful response with detailed analysis data', () => {
      const repoId = 789;
      const detailedResponse = {
        repositoryId: repoId,
        analysisStatus: 'COMPLETED',
        vulnerabilitiesFound: 5,
        exploitabilityScore: 7.5,
        findings: [
          { id: 1, severity: 'HIGH', exploitable: true },
          { id: 2, severity: 'MEDIUM', exploitable: false }
        ],
        timestamp: '2024-01-15T10:30:00Z'
      };

      service.analyzeRepository(repoId).subscribe(response => {
        expect(response.repositoryId).toBe(repoId);
        expect(response.analysisStatus).toBe('COMPLETED');
        expect(response.vulnerabilitiesFound).toBe(5);
        expect(response.findings).toHaveSize(2);
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush(detailedResponse);
    });

    it('should handle error response - repository not found', () => {
      const repoId = 999;
      const errorResponse = {
        status: 404,
        statusText: 'Not Found',
        error: { message: 'Repository not found' }
      };

      service.analyzeRepository(repoId).subscribe({
        next: () => fail('should have failed with 404 error'),
        error: (error) => {
          expect(error.status).toBe(404);
          expect(error.error.message).toBe('Repository not found');
        }
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush(
          { message: 'Repository not found' },
          { status: 404, statusText: 'Not Found' }
      );
    });

    it('should handle error response - unauthorized access', () => {
      const repoId = 100;

      service.analyzeRepository(repoId).subscribe({
        next: () => fail('should have failed with 401 error'),
        error: (error) => {
          expect(error.status).toBe(401);
        }
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush(
          { message: 'Unauthorized' },
          { status: 401, statusText: 'Unauthorized' }
      );
    });

    it('should handle error response - forbidden access', () => {
      const repoId = 200;

      service.analyzeRepository(repoId).subscribe({
        next: () => fail('should have failed with 403 error'),
        error: (error) => {
          expect(error.status).toBe(403);
          expect(error.error.message).toContain('permission');
        }
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush(
          { message: 'You do not have permission to analyze this repository' },
          { status: 403, statusText: 'Forbidden' }
      );
    });

    it('should handle server error', () => {
      const repoId = 300;

      service.analyzeRepository(repoId).subscribe({
        next: () => fail('should have failed with 500 error'),
        error: (error) => {
          expect(error.status).toBe(500);
        }
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush(
          { message: 'Internal server error' },
          { status: 500, statusText: 'Internal Server Error' }
      );
    });

    it('should handle network error', () => {
      const repoId = 400;
      const mockError = new ProgressEvent('error');

      service.analyzeRepository(repoId).subscribe({
        next: () => fail('should have failed with network error'),
        error: (error) => {
          expect(error.error).toBe(mockError);
        }
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.error(mockError);
    });

    it('should handle concurrent requests for different repositories', () => {
      const repoIds = [1, 2, 3];
      const responses = repoIds.map(id => ({ repoId: id, status: 'queued' }));

      // Make concurrent requests
      repoIds.forEach((id, index) => {
        service.analyzeRepository(id).subscribe(response => {
          expect(response).toEqual(responses[index]);
        });
      });

      // Verify all requests were made
      repoIds.forEach((id, index) => {
        const req = httpMock.expectOne(
            `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${id}`
        );
        req.flush(responses[index]);
      });
    });

    it('should handle response with empty data', () => {
      const repoId = 500;

      service.analyzeRepository(repoId).subscribe(response => {
        expect(response).toEqual({});
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush({});
    });

    it('should handle response indicating analysis already in progress', () => {
      const repoId = 600;
      const inProgressResponse = {
        status: 'IN_PROGRESS',
        message: 'Analysis is already running for this repository',
        progress: 45
      };

      service.analyzeRepository(repoId).subscribe(response => {
        expect(response.status).toBe('IN_PROGRESS');
        expect(response.progress).toBe(45);
      });

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req.flush(inProgressResponse);
    });

    it('should return Observable that can be subscribed multiple times', () => {
      const repoId = 700;
      const mockResponse = { status: 'success' };

      const observable = service.analyzeRepository(repoId);

      // First subscription
      observable.subscribe(response => {
        expect(response).toEqual(mockResponse);
      });

      const req1 = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req1.flush(mockResponse);

      // Second subscription (creates new HTTP request)
      observable.subscribe(response => {
        expect(response).toEqual(mockResponse);
      });

      const req2 = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${repoId}`
      );
      req2.flush(mockResponse);
    });
  });

  describe('Edge Cases', () => {
    it('should handle very large repository ID', () => {
      const largeId = 999999999;

      service.analyzeRepository(largeId).subscribe();

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${largeId}`
      );
      expect(req.request.url).toContain(`repoId=${largeId}`);
      req.flush({});
    });

    it('should handle repository ID of 0', () => {
      const zeroId = 0;

      service.analyzeRepository(zeroId).subscribe();

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${zeroId}`
      );
      expect(req.request.url).toContain('repoId=0');
      req.flush({});
    });

    it('should handle negative repository ID', () => {
      const negativeId = -1;

      service.analyzeRepository(negativeId).subscribe();

      const req = httpMock.expectOne(
          `${baseUrl}/api/v1/exploitability/analyzeRepository?repoId=${negativeId}`
      );
      expect(req.request.url).toContain('repoId=-1');
      req.flush({});
    });
  });
});