import {Component, EventEmitter, Input, OnChanges, Output, SimpleChanges} from '@angular/core';
import {CommonModule} from '@angular/common';
import {FunnelStepData} from "./funnel-step-data";
import {FunnelSteps} from "./funnel-steps";
import {environment} from "../../../../environments/environment";

@Component({
  selector: 'app-exploit-funnel',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './exploit-funnel.component.html',
  styleUrls: ['./exploit-funnel.component.scss']
})
export class ExploitFunnelComponent implements OnChanges {
  @Input() vulns: any[] = [];
  @Output() filterSeverityChange = new EventEmitter<any>();

  protected steps: any[] = [];

  // Paths for the 3 layers
  protected pathTotal: string = '';   // Represents Total (Other + High + Critical)
  protected pathHigh: string = '';    // Represents High + Critical
  protected pathCritical: string = ''; // Represents Critical

  protected hoveredStepIndex: number | null = null;
  protected tooltipPosition = { x: 0, y: 0 };

  private data: Map<FunnelSteps, FunnelStepData> = new Map();

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['vulns']) {
      this.calculateStats();
      this.generateFunnelPaths();
    }
  }

  calculateStats() {
    if (!this.vulns) return;

    this.data = new Map();
    Object.values(FunnelSteps).forEach(step => {
      let funnelStepData = this.calculateStatsForStep(step);

      this.data.set(step, funnelStepData);
    });

    this.steps = [
      this.createStep(FunnelSteps.TOTAL, this.data.get(FunnelSteps.TOTAL)),
      this.createStep(FunnelSteps.UNANALYZED, this.data.get(FunnelSteps.UNANALYZED)),
      this.createStep(FunnelSteps.KNOWN_EXPLOIT, this.data.get(FunnelSteps.KNOWN_EXPLOIT)),
      this.createStep(FunnelSteps.LIKELY, this.data.get(FunnelSteps.LIKELY)),
      this.createStep(FunnelSteps.REACHABLE, this.data.get(FunnelSteps.REACHABLE))
    ];
  }

  private calculateStatsForStep(step: FunnelSteps): FunnelStepData {
    let funnelStepData: FunnelStepData = {
      total: 0,
      critical: 0,
      high: 0
    }

    switch (step) {
      case FunnelSteps.TOTAL: {
        funnelStepData.total = this.vulns.length;
        funnelStepData.critical = this.vulns.filter(v => v.severity?.toLowerCase() === 'critical').length;
        funnelStepData.high = this.vulns.filter(v => v.severity?.toLowerCase() === 'high').length;
        break;
      }
      case FunnelSteps.UNANALYZED: {
        const unanalyzedVulns = this.vulns.filter(v => v.predictedProbability == null);
        funnelStepData.total = unanalyzedVulns.length;
        funnelStepData.critical = unanalyzedVulns.filter(v => v.severity?.toLowerCase() === 'critical').length;
        funnelStepData.high = unanalyzedVulns.filter(v => v.severity?.toLowerCase() === 'high').length;
        break;
      }
      case FunnelSteps.KNOWN_EXPLOIT: {
        const knownExploitableVulns = this.vulns.filter(v => v.knownExploit == true);
        funnelStepData.total = knownExploitableVulns.length;
        funnelStepData.critical = knownExploitableVulns.filter(v => v.severity?.toLowerCase() === 'critical').length;
        funnelStepData.high = knownExploitableVulns.filter(v => v.severity?.toLowerCase() === 'high').length;
        break;
      }
      case FunnelSteps.LIKELY: {
        const likelyExploitableVulns = this.vulns.filter(v => v.predictedProbability > environment.likelyExploitThreshold);
        funnelStepData.total = likelyExploitableVulns.length;
        funnelStepData.critical = likelyExploitableVulns.filter(v => v.severity?.toLowerCase() === 'critical').length;
        funnelStepData.high = likelyExploitableVulns.filter(v => v.severity?.toLowerCase() === 'high').length;
        break;
      }
      case FunnelSteps.REACHABLE: {
        const reachableExploitableVulns = this.vulns.filter(v => v.predictedProbability > environment.reachableExploitThreshold);
        funnelStepData.total = reachableExploitableVulns.length;
        funnelStepData.critical = reachableExploitableVulns.filter(v => v.severity?.toLowerCase() === 'critical').length;
        funnelStepData.high = reachableExploitableVulns.filter(v => v.severity?.toLowerCase() === 'high').length;
        break;
      }
    }
    return funnelStepData;
  }

  private createStep (stepLabel: string, stepData: FunnelStepData | undefined): any {
    if (!stepData) return;

    return {
      label: stepLabel,
      value: stepData.total,
      breakdown: {
        critical: stepData.critical,
        high: stepData.high,
        other: (stepData.total - stepData.critical - stepData.high)
      }
    }
  }

  generateFunnelPaths() {
    if (this.steps.length === 0) return;

    // We generate 3 paths based on cumulative values
    // Layer 1 (Bottom/Back): Total Value (Other + High + Critical) -> pathTotal
    // Layer 2 (Middle): High + Critical -> pathHigh
    // Layer 3 (Top/Front): Critical -> pathCritical

    const valuesTotal = this.steps.map(s => s.value);
    const valuesHighPlusCrit = this.steps.map(s => s.breakdown.high + s.breakdown.critical);
    const valuesCrit = this.steps.map(s => s.breakdown.critical);

    this.pathTotal = this.calculatePathString(valuesTotal);
    this.pathHigh = this.calculatePathString(valuesHighPlusCrit);
    this.pathCritical = this.calculatePathString(valuesCrit);
  }

  calculatePathString(values: number[]): string {
    const width = 100;
    const stepWidth = width / values.length;
    const points: { x: number, yTop: number, yBottom: number }[] = [];

    values.forEach((value, index) => {
      // Calculate percentage relative to the GLOBAL total (first step of total)
      // This ensures the layers stack correctly visually relative to the max height
      const globalTotal = this.data.get(FunnelSteps.TOTAL)?.total ?? this.vulns.length;
      const percent = globalTotal > 0 ? (value / globalTotal) : 0;

      // Min height logic: if value is 0, height is 0. If value > 0, min height 2%.
      let h = 0;
      if (value > 0) {
        h = Math.max(percent * 100, 2);
      }

      const x = index * stepWidth;
      const yTop = (100 - h) / 2;
      const yBottom = 100 - yTop;

      points.push({ x, yTop, yBottom });
    });

    // Add final point
    if (points.length > 0) {
      const lastPoint = points[points.length - 1];
      points.push({
        x: 100,
        yTop: lastPoint.yTop,
        yBottom: lastPoint.yBottom
      });
    }

    if (points.length === 0) return '';

    let d = `M ${points[0].x},${points[0].yTop}`;

    // Top curve
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const cp1x = (p0.x + p1.x) / 2;
      const cp1y = p0.yTop;
      const cp2x = (p0.x + p1.x) / 2;
      const cp2y = p1.yTop;
      d += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p1.x},${p1.yTop}`;
    }

    // Down to bottom
    d += ` L ${points[points.length - 1].x},${points[points.length - 1].yBottom}`;

    // Bottom curve (backwards)
    for (let i = points.length - 1; i > 0; i--) {
      const p1 = points[i];
      const p0 = points[i - 1];
      const cp1x = (p0.x + p1.x) / 2;
      const cp1y = p1.yBottom;
      const cp2x = (p0.x + p1.x) / 2;
      const cp2y = p0.yBottom;
      d += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p0.x},${p0.yBottom}`;
    }

    d += ' Z';
    return d;
  }

  onLayerClick(event: MouseEvent, layer: 'total' | 'High' | 'Critical') {
    if (layer === 'total') {
      this.filterSeverityChange.emit({ target: { value: '' } });
    } else {
      this.filterSeverityChange.emit({ target: { value: layer } });
    }
  }

  onStepHover(index: number) {
    this.hoveredStepIndex = index;
  }

  onStepLeave() {
    this.hoveredStepIndex = null;
  }

  onMouseMove(event: MouseEvent) {
    this.tooltipPosition = {
      x: event.clientX,
      y: event.clientY
    };
  }


}
