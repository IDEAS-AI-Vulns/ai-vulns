import { Component, Input, OnChanges, SimpleChanges } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-exploit-funnel',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './exploit-funnel.component.html',
  styleUrls: ['./exploit-funnel.component.scss']
})
export class ExploitFunnelComponent implements OnChanges {
  @Input() vulns: any[] = [];

  data = {
    total: 0,
    knownExploit: 0,
    likelyReachable: 0,
    reachable: 0,
    critical: 0,
    high: 0
  };

  steps: any[] = [];

  // Paths for the 3 layers
  pathTotal: string = '';   // Represents Total (Other + High + Critical)
  pathHigh: string = '';    // Represents High + Critical
  pathCritical: string = ''; // Represents Critical

  hoveredStepIndex: number | null = null;
  tooltipPosition = { x: 0, y: 0 };

  onStepHover(index: number) {
    this.hoveredStepIndex = index;
  }

  onStepLeave() {
    this.hoveredStepIndex = null;
  }

  onMouseMove(event: MouseEvent) {
    this.tooltipPosition = {
      x: event.clientX,
      y: event.clientY
    };
  }

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['vulns']) {
      this.calculateStats();
      this.generateFunnelPaths();
    }
  }

  calculateStats() {
    if (!this.vulns) return;

    // Real total
    this.data.total = this.vulns.length;

    // Hardcoded demo values as requested
    this.data.knownExploit = Math.round(this.data.total * 0.70);
    this.data.likelyReachable = Math.round(this.data.knownExploit * 0.40);
    this.data.reachable = Math.round(this.data.likelyReachable * 0.05);

    this.data.critical = this.vulns.filter(v => v.severity?.toLowerCase() === 'critical').length;
    this.data.high = this.vulns.filter(v => v.severity?.toLowerCase() === 'high').length;

    console.log('ExploitFunnel Stats:', {
      total: this.data.total,
      critical: this.data.critical,
      high: this.data.high,
      knownExploit: this.data.knownExploit
    });

    // We need to store the breakdown for each step to generate paths
    // Step 1: Real distribution
    // Steps 2-4: 33% distribution as requested

    const createStep = (label: string, value: number, icon: string, isFirst: boolean) => {
      let crit, high, other;

      if (isFirst) {
        crit = this.data.critical;
        high = this.data.high;
        other = this.data.total - crit - high;
      } else {
        // 33% split
        crit = Math.round(value * 0.33);
        high = Math.round(value * 0.33);
        other = value - crit - high; // Remainder
      }

      return {
        label,
        value,
        icon,
        breakdown: {
          critical: crit,
          high: high,
          other: other
        }
      };
    };

    this.steps = [
      createStep('Total', this.data.total, 'â­', true),
      createStep('Known exploit', this.data.knownExploit, 'ðŸ”´', false),
      createStep('Likely reachable', this.data.likelyReachable, 'ðŸŸ ', false),
      createStep('Reachable', this.data.reachable, 'ðŸ”¥', false)
    ];
  }

  generateFunnelPaths() {
    if (this.steps.length === 0) return;

    // We generate 3 paths based on cumulative values
    // Layer 1 (Bottom/Back): Total Value (Other + High + Critical) -> pathTotal
    // Layer 2 (Middle): High + Critical -> pathHigh
    // Layer 3 (Top/Front): Critical -> pathCritical

    const valuesTotal = this.steps.map(s => s.value);
    const valuesHighPlusCrit = this.steps.map(s => s.breakdown.high + s.breakdown.critical);
    const valuesCrit = this.steps.map(s => s.breakdown.critical);

    this.pathTotal = this.calculatePathString(valuesTotal);
    this.pathHigh = this.calculatePathString(valuesHighPlusCrit);
    this.pathCritical = this.calculatePathString(valuesCrit);
  }

  calculatePathString(values: number[]): string {
    const width = 100;
    const stepWidth = width / values.length;
    const points: { x: number, yTop: number, yBottom: number }[] = [];

    values.forEach((value, index) => {
      // Calculate percentage relative to the GLOBAL total (first step of total)
      // This ensures the layers stack correctly visually relative to the max height
      const globalTotal = this.data.total;
      const percent = globalTotal > 0 ? (value / globalTotal) : 0;

      // Min height logic: if value is 0, height is 0. If value > 0, min height 2%.
      let h = 0;
      if (value > 0) {
        h = Math.max(percent * 100, 2);
      }

      const x = index * stepWidth;
      const yTop = (100 - h) / 2;
      const yBottom = 100 - yTop;

      points.push({ x, yTop, yBottom });
    });

    // Add final point
    if (points.length > 0) {
      const lastPoint = points[points.length - 1];
      points.push({
        x: 100,
        yTop: lastPoint.yTop,
        yBottom: lastPoint.yBottom
      });
    }

    if (points.length === 0) return '';

    let d = `M ${points[0].x},${points[0].yTop}`;

    // Top curve
    for (let i = 0; i < points.length - 1; i++) {
      const p0 = points[i];
      const p1 = points[i + 1];
      const cp1x = (p0.x + p1.x) / 2;
      const cp1y = p0.yTop;
      const cp2x = (p0.x + p1.x) / 2;
      const cp2y = p1.yTop;
      d += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p1.x},${p1.yTop}`;
    }

    // Down to bottom
    d += ` L ${points[points.length - 1].x},${points[points.length - 1].yBottom}`;

    // Bottom curve (backwards)
    for (let i = points.length - 1; i > 0; i--) {
      const p1 = points[i];
      const p0 = points[i - 1];
      const cp1x = (p0.x + p1.x) / 2;
      const cp1y = p1.yBottom;
      const cp2x = (p0.x + p1.x) / 2;
      const cp2y = p0.yBottom;
      d += ` C ${cp1x},${cp1y} ${cp2x},${cp2y} ${p0.x},${p0.yBottom}`;
    }

    d += ' Z';
    return d;
  }
}
