import {Component, Input, OnChanges, SimpleChanges} from '@angular/core';
import {CommonModule} from '@angular/common';
import {TooltipModule} from '@coreui/angular';

@Component({
    selector: 'app-reachability-graph',
    standalone: true,
    imports: [CommonModule, TooltipModule],
    templateUrl: './reachability-graph.component.html',
    styleUrls: ['./reachability-graph.component.scss']
})
export class ReachabilityGraphComponent implements OnChanges {
    @Input() score: number | null = null;

    // Path segments now support custom styling per segment
    pathSegments: {
        d: string,
        dashed: boolean,
        showArrow: boolean,
        color?: string,
        width?: number,
        opacity?: number
    }[] = [];

    checkpoints: { x: number, y: number }[] = [];

    // Dead ends for spaghetti mode: path + end coordinate for 'X' marker
    deadEnds: { d: string, endX: number, endY: number }[] = [];

    showCloud: boolean = false;

    // Dimensions
    width = 600;
    height = 200; // Increased height for more "looping" space
    padding = 60;

    ngOnChanges(changes: SimpleChanges): void {
        this.generateVisualization();
    }

    generateVisualization() {
        this.checkpoints = [];
        this.pathSegments = [];
        this.deadEnds = [];
        this.showCloud = false;

        const startX = this.padding;
        const startY = this.height / 2;
        const endX = this.width - this.padding;
        const endY = this.height / 2;

        console.log(this.score);
        if (this.score === null || this.score === undefined) {
            // Unknown
            this.pathSegments.push({
                d: `M ${startX},${startY} L ${endX},${endY}`,
                dashed: true,
                showArrow: true
            });
            this.showCloud = true;
            return;
        }

        if (this.score < 0.3) {
            console.log('below 0.3');
            // Spaghetti Mode:
            // 1. Main path: Thick, dashed, winding, yellow/warning color
            // 2. Dead ends: 4 paths, thinner, gray, ending in X

            // Main Path
            this.pathSegments.push({
                d: this.generateSpaghettiPath(startX, startY, endX, endY),
                dashed: true,
                showArrow: true,
                color: 'var(--cui-warning)',
                width: 4,
                opacity: 1
            });

            // Dead Ends
            this.generateDeadEnds(startX, startY, endX, endY);

        } else if (this.score < 0.6) {
            console.log('below 0.6');
            // 2 Checkpoints
            const cp1x = startX + (endX - startX) * 0.33;
            const cp2x = startX + (endX - startX) * 0.66;

            this.checkpoints.push({ x: cp1x, y: startY });
            this.checkpoints.push({ x: cp2x, y: startY });

            this.pathSegments.push({
                d: this.generateZigZagPath(startX, startY, cp1x, startY),
                dashed: false,
                showArrow: false
            });

            this.pathSegments.push({
                d: this.generateZigZagPath(cp1x, startY, endX, endY),
                dashed: true,
                showArrow: true
            });

        } else if (this.score < 0.9) {
            console.log('below 0.9');
            // 1 Checkpoint
            const cp1x = startX + (endX - startX) * 0.5;
            this.checkpoints.push({ x: cp1x, y: startY });

            this.pathSegments.push({
                d: this.generateWavyPath(startX, startY, endX, endY),
                dashed: false,
                showArrow: true
            });
        } else {

            console.log('straight');
            // Straight
            this.pathSegments.push({
                d: `M ${startX},${startY} L ${endX},${endY}`,
                dashed: false,
                showArrow: true
            });
        }
    }

    generateSpaghettiPath(x1: number, y1: number, x2: number, y2: number): string {
        // A very winding path that eventually reaches the end
        let d = `M ${x1},${y1}`;
        // We'll use multiple bezier curves to simulate the "maze" look
        // Up, Down, Loop around
        d += ` C ${x1 + 100},${y1 - 200} ${x1 + 100},${y1 + 200} ${x1 + 200},${y1}`;
        d += ` C ${x1 + 300},${y1 + 150} ${x1 + 250},${y1 - 150} ${x1 + 350},${y1}`;
        d += ` C ${x1 + 400},${y1 - 100} ${x1 + 450},${y1 + 100} ${x2},${y2}`;
        return d;
    }

    generateDeadEnds(startX: number, startY: number, endX: number, endY: number) {
        const numDeadEnds = 4;
        for (let i = 0; i < numDeadEnds; i++) {
            // Random end point somewhere in the middle-ish
            const ex = startX + 100 + Math.random() * (endX - startX - 150);
            const ey = 20 + Math.random() * (this.height - 40);

            let d = `M ${startX},${startY}`;
            // Random control points
            const cp1x = startX + Math.random() * 100;
            const cp1y = startY + (Math.random() - 0.5) * 200;

            d += ` Q ${cp1x},${cp1y} ${ex},${ey}`;

            this.deadEnds.push({
                d: d,
                endX: ex,
                endY: ey
            });
        }
    }

    generateZigZagPath(x1: number, y1: number, x2: number, y2: number): string {
        let d = `M ${x1},${y1}`;
        const steps = 6;
        const stepX = (x2 - x1) / steps;

        for (let i = 1; i <= steps; i++) {
            const x = x1 + i * stepX;
            // Zigzag up/down
            const y = y1 + (i % 2 === 0 ? 0 : (i % 4 === 1 ? -30 : 30));
            d += ` L ${x},${y}`;
        }
        d += ` L ${x2},${y2}`; // Ensure we hit the exact end point
        return d;
    }

    generateWavyPath(x1: number, y1: number, x2: number, y2: number): string {
        // Gentle sine wave
        let d = `M ${x1},${y1}`;
        const midX = (x1 + x2) / 2;
        // Control points for S-curve
        d += ` Q ${x1 + (midX - x1) / 2},${y1 - 40} ${midX},${y1}`;
        d += ` Q ${midX + (x2 - midX) / 2},${y1 + 40} ${x2},${y2}`;
        return d;
    }
}
