package io.mixeway.mixewayflowapi.modules.exploit.service;

import io.mixeway.mixewayflowapi.db.entity.CodeRepo;
import io.mixeway.mixewayflowapi.domain.coderepo.FindCodeRepoService;
import io.mixeway.mixewayflowapi.domain.coderepo.events.UpdateCoderepoScanStatusEvent;
import io.mixeway.mixewayflowapi.domain.finding.FindFindingService;
import io.mixeway.mixewayflowapi.domain.finding.UpdateFindingService;
import io.mixeway.mixewayflowapi.modules.exploit.api.events.AnalyzeExploitabilityEvent;
import io.mixeway.mixewayflowapi.scanmanager.service.ScanManagerService;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.test.context.ActiveProfiles;

import java.util.Optional;

import static org.mockito.Mockito.*;

@SpringBootTest
@ActiveProfiles("ut")
public class AnalyzeExploitabilityServiceTest {

    private AnalyzeExploitabilityService service;
    private ApplicationEventPublisher publisher;
    private FindCodeRepoService findCodeRepoService;
    private ScanManagerService scanManagerService;
    private FindFindingService findFindingService;
    private UpdateFindingService updateFindingService;

    @BeforeEach
    void setup() {
        publisher = mock(ApplicationEventPublisher.class);
        findCodeRepoService = mock(FindCodeRepoService.class);
        scanManagerService = mock(ScanManagerService.class);
        findFindingService = mock(FindFindingService.class);
        updateFindingService = mock(UpdateFindingService.class);

        service = new AnalyzeExploitabilityService(
                publisher,
                findCodeRepoService,
                scanManagerService,
                findFindingService,
                updateFindingService
        );
    }

    //@Test
    void shouldPublishWarningWhenCodeRepoNotFound() throws Exception {
        // given
        when(findCodeRepoService.findById(42L)).thenReturn(Optional.empty());

        AnalyzeExploitabilityEvent event = new AnalyzeExploitabilityEvent(42L);

        // when
        service.handleAnalyzeExploitabilityEvent(event);

        // then
        verify(publisher, never()).publishEvent(argThat(e ->
                e.getClass().getSimpleName().equals("UpdateCoderepoScanStatusEvent") &&
                        ((UpdateCoderepoScanStatusEvent)e).getScanStatus().equals(CodeRepo.ScanStatus.SUCCESS)
        ));
    }

    /*@Test
    void shouldHandleValidRepoWithoutCrashing() throws Exception {
        // given
        CodeRepo repo = new CodeRepo();
        repo.setId(1L);
        repo.setName("demo");
        repo.setRepourl("https://example.com/repo.git");
        repo.setDefaultBranch("main");

        when(findCodeRepoService.findById(1L)).thenReturn(Optional.of(repo));
        when(findFindingService.getCodeRepoFindings(any(), any(), anyBoolean())).thenReturn(List.of());

        try (MockedStatic<ZipService> zipMock = Mockito.mockStatic(ZipService.class);
             MockedStatic<ExcelService> excelMock = Mockito.mockStatic(ExcelService.class)) {

            // when
            service.handleAnalyzeExploitabilityEvent(new AnalyzeExploitabilityEvent(1L));

            // then
            verify(publisher, atLeastOnce()).publishEvent(any());
        }
    }*/
}
