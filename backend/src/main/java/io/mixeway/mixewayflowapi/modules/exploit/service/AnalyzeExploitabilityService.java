package io.mixeway.mixewayflowapi.modules.exploit.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.mixeway.mixewayflowapi.db.entity.CodeRepo;
import io.mixeway.mixewayflowapi.db.entity.Finding;
import io.mixeway.mixewayflowapi.db.entity.Vulnerability;
import io.mixeway.mixewayflowapi.domain.coderepo.FindCodeRepoService;
import io.mixeway.mixewayflowapi.domain.coderepo.events.UpdateCoderepoScanStatusEvent;
import io.mixeway.mixewayflowapi.domain.finding.FindFindingService;
import io.mixeway.mixewayflowapi.domain.finding.UpdateFindingService;
import io.mixeway.mixewayflowapi.integrations.exploit.model.AnalysisResult;
import io.mixeway.mixewayflowapi.modules.exploit.api.events.AnalyzeExploitabilityEvent;
import io.mixeway.mixewayflowapi.modules.exploit.exception.ExploitabilityScriptProcessingException;
import io.mixeway.mixewayflowapi.scanmanager.service.ScanManagerService;
import io.mixeway.mixewayflowapi.utils.ExcelService;
import io.mixeway.mixewayflowapi.utils.ZipService;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.Optional;
import java.util.stream.StreamSupport;

@Service
@Log4j2
@RequiredArgsConstructor
public class AnalyzeExploitabilityService {

    private final ApplicationEventPublisher publisher;

    @Value( "${exploitability.path-name}" )
    private String exploitabilityScriptPathName;

    @Value( "${exploitability.path-name.data}" )
    private String exploitabilityScriptPathNameData;

    @Value( "${exploitability.path-name.results}" )
    private String exploitabilityScriptPathNameResults;

    private final FindCodeRepoService findCodeRepoService;
    private final ScanManagerService scanManagerService;
    private final FindFindingService findFindingService;
    private final UpdateFindingService updateFindingService;

    @Scheduled(initialDelay = 100, fixedDelay = 3600000)
    protected void analyzeNotScannedRepositories() {
        Iterable<CodeRepo> allRepositories = findCodeRepoService.findAll();

        log.debug("Starting analysis of not scanned repositories");
        List<Long> repoIds = StreamSupport.stream(allRepositories.spliterator(), false)
                        .filter(codeRepo -> !codeRepo.getExploitabilityScan().equals(CodeRepo.ScanStatus.SUCCESS))
                        .filter(this::findSCAVulnerabilities)
                        .limit(10)
                        .map(CodeRepo::getId)
                        .toList();

        repoIds.forEach(repoId -> {
            log.debug("Analyzing repository with id: {}", repoId);
            AnalyzeExploitabilityEvent analyzeExploitabilityEvent = new AnalyzeExploitabilityEvent(repoId);
            publisher.publishEvent(analyzeExploitabilityEvent);
        });
    }

    private boolean findSCAVulnerabilities(CodeRepo codeRepo) {
        boolean hasSCAVulnerabilities = false;
        List<Finding> findings = findFindingService.getCodeRepoFindings(codeRepo, codeRepo.getDefaultBranch(), false);

        for (Finding finding : findings) {
            if (finding.getSource()!= null && finding.getSource().equals(Finding.Source.SCA))
                hasSCAVulnerabilities = true;
        }
        return hasSCAVulnerabilities;
    }

    @Async
    @EventListener
    public void handleAnalyzeExploitabilityEvent(AnalyzeExploitabilityEvent analyzeExploitabilityEvent) throws IOException {
        log.debug("Received AnalyzeExploitabilityEvent, repository id:{}", analyzeExploitabilityEvent.getRepositoryId());
        analyzeRepositoryExploitability(analyzeExploitabilityEvent.getRepositoryId());
    }

    private void analyzeRepositoryExploitability(long repositoryId) throws IOException {
        log.debug("Starting analysis of the repository {}", repositoryId);
        AnalyzeExploitabilityData exploitabilityData = new AnalyzeExploitabilityData();

        try {
            //Find proper Code Repository
            getCodeRepo(repositoryId, exploitabilityData);
            if (exploitabilityData.getCodeRepo() == null) return;

            //Preparation of the directory and path names
            prepareDirNames(exploitabilityData);

            //Archiving the repository
            archiveRepository(exploitabilityData);

            //Preparation of the Excel
            prepareExcelFile(exploitabilityData);

            //analysis of the exploitability
            executeAnalysis(exploitabilityData.getCodeRepoDirName() + ".zip",
                    exploitabilityData.getCodeRepoDirName() + ".xlsx");

            //Processing of the results
            processResults(exploitabilityData);

            publisher.publishEvent(new UpdateCoderepoScanStatusEvent(exploitabilityData.getCodeRepo(), CodeRepo.ScanStatus.SUCCESS));
        } catch (ExploitabilityScriptProcessingException e) {
            log.error("Error occurred while analysing repository within python script");
            log.error(e.getMessage());

            publisher.publishEvent(new UpdateCoderepoScanStatusEvent(exploitabilityData.getCodeRepo(), CodeRepo.ScanStatus.WARNING));
        }  catch (InterruptedException e) {
            log.error("Error occurred while analysing repository");
            log.error(e.getMessage());

            publisher.publishEvent(new UpdateCoderepoScanStatusEvent(exploitabilityData.getCodeRepo(), CodeRepo.ScanStatus.WARNING));
        } finally {
            //Files.deleteIfExists(Paths.get(exploitabilityData.getCodeRepoDirName() + ".zip"));
            //Files.deleteIfExists(Paths.get(exploitabilityData.getCodeRepoDirName() + ".xlsx"));
            //File dir = new File(exploitabilityData.getCodeRepoDirName());
            //if (dir.exists() && dir.isDirectory()) {
            //    FileUtils.deleteDirectory(dir);
            //}
        }
    }

    private void getCodeRepo(long repositoryId, AnalyzeExploitabilityData exploitabilityData) {
        Optional<CodeRepo> codeRepoOptional = findCodeRepoService.findById(repositoryId);
        if (codeRepoOptional.isEmpty()) {
            log.error("Code Repository with id: {} not found!", repositoryId);
            return;
        }
        CodeRepo codeRepo = codeRepoOptional.get();
        exploitabilityData.setCodeRepo(codeRepo);

        publisher.publishEvent(new UpdateCoderepoScanStatusEvent(codeRepo, CodeRepo.ScanStatus.RUNNING));
    }

    private void prepareDirNames(AnalyzeExploitabilityData exploitabilityData) {
        assert exploitabilityData.getCodeRepo().getName() != null;

        String repoName = exploitabilityData.getCodeRepo().getName().replace("/", "-");
        String repoDirName =    exploitabilityScriptPathName + File.separator +
                                exploitabilityScriptPathNameData + File.separator +
                                repoName /*+ "-" + Instant.now().toEpochMilli()*/;

        exploitabilityData.setCodeRepoName(repoName);
        exploitabilityData.setCodeRepoDirName(repoDirName);
    }

    private void archiveRepository(AnalyzeExploitabilityData exploitabilityData) throws IOException, InterruptedException {
        scanManagerService.fetchRepository( null,
                                                    exploitabilityData.getCodeRepo().getRepourl(),
                                                    exploitabilityData.getCodeRepo().getAccessToken(),
                                                    exploitabilityData.getCodeRepo().getDefaultBranch(),
                                                    exploitabilityData.getCodeRepoDirName());

        ZipService.zipDirectory(new File(exploitabilityData.getCodeRepoDirName()),
                                new File(exploitabilityData.getCodeRepoDirName() + ".zip"));
    }

    private void prepareExcelFile(AnalyzeExploitabilityData exploitabilityData) {
        List<Finding> findings = findFindingService.getCodeRepoFindings(exploitabilityData.getCodeRepo(),
                                                                        exploitabilityData.getCodeRepo().getDefaultBranch(),
                                                                        true);
        exploitabilityData.setFindings(findings);

        List<Vulnerability> vulnerabilities = findings.stream()
                                                        .map(Finding::getVulnerability)
                                                        .toList();

        ExcelService.createVulnerabilitySummaryExcel(vulnerabilities,
                                                    exploitabilityData.getCodeRepo().getRepourl(),
                                                    exploitabilityData.getCodeRepoName(),
                                                    exploitabilityData.getCodeRepoDirName());
    }

    private void processResults(AnalyzeExploitabilityData exploitabilityData) throws IOException {

        String resultsPath =    exploitabilityScriptPathNameResults + File.separator +
                                exploitabilityData.getCodeRepoName() + File.separator +
                                exploitabilityData.getCodeRepoName() + ".json";

        ObjectMapper objectMapper = new ObjectMapper();

        String fullPath =   System.getProperty("user.dir") + File.separator +
                            exploitabilityScriptPathName + File.separator +
                            resultsPath;

        List<AnalysisResult> results;
        try (InputStream inputStream = Files.newInputStream(Paths.get(fullPath))) {
            results = objectMapper.readValue(inputStream, new TypeReference<>() {});
        }

        for (AnalysisResult result : results) {
            Finding analyzedFinding = exploitabilityData.getFindings().stream().filter(finding -> {
                assert finding.getVulnerability() != null;
                return finding.getVulnerability().getName().equals(result.getVulnerability_name());
            }).toList().getFirst();

            analyzedFinding.setConfidence(result.getConfidence());
            analyzedFinding.setDetectedMitigations(String.join("; ", result.getMitigations_detected()));
            analyzedFinding.setSuggestedNextSteps(result.getSuggested_next_steps());
            analyzedFinding.setPredictedProbability(result.getPredicted_probability());
            analyzedFinding.setPredictedExploitable(result.getPredicted_exploitable());
            analyzedFinding.setDetailedReasoning(result.getDetailed_reasoning());
        }

        updateFindingService.updateFindings(exploitabilityData.getFindings());
    }

    private String executeAnalysis(String repoPath, String vulnerabilitiesExcelPath) throws IOException, InterruptedException {
        //removal of script root since execution is within it:
        repoPath = repoPath.replace(exploitabilityScriptPathName + File.separator, "");
        vulnerabilitiesExcelPath = vulnerabilitiesExcelPath.replace(exploitabilityScriptPathName + File.separator, "");

        // Project root
        File projectRoot = new File(System.getProperty("user.dir"), exploitabilityScriptPathName);

        // Detect OS â†’ choose correct venv Python path
        String osName = System.getProperty("os.name").toLowerCase();
        String venvPython = getPython(osName, projectRoot);

        log.debug("Starting of the python exploitability script");
        ProcessBuilder pb = new ProcessBuilder(
                venvPython,
                "-m", "src",
                "analyze", repoPath, vulnerabilitiesExcelPath
        );
        pb.directory(projectRoot);
        pb.environment().put("PYTHONUTF8", "1");
        pb.redirectErrorStream(true);

        // Start the process
        Process process = pb.start();

        // Capture output in real-time
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
                log.debug(line); // Optional: log in real-time
            }
        }

        int exitCode = process.waitFor();
        if (exitCode != 0) {
            throw new ExploitabilityScriptProcessingException("Execution failed with code " + exitCode + "\n" + output);
        }

        return output.toString();
    }

    private static String getPython(String osName, File projectRoot) {
        String pythonRelative;
        if (osName.contains("win")) {
            pythonRelative = ".venv" + File.separator + "Scripts" + File.separator + "python.exe";
        } else {
            pythonRelative = ".venv" + File.separator + "bin" + File.separator + "python";
        }

        File pythonExe = new File(projectRoot, pythonRelative);
        String venvPython = pythonExe.getAbsolutePath();

        if (!pythonExe.exists()) {
            throw new IllegalStateException("Python executable not found: " + venvPython);
        }
        return venvPython;
    }
}
