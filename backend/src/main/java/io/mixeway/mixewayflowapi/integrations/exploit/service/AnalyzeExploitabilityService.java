package io.mixeway.mixewayflowapi.integrations.exploit.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.mixeway.mixewayflowapi.integrations.exploit.model.AnalysisResult;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.List;

@Service
@Log4j2
public class AnalyzeExploitabilityService {

    public String analyzeTestRepository() throws IOException {
        log.info("Starting analysis of the repository");

        //executeAnalysis("data/transformers-main.zip", "data/transformers-main.xlsx");
        processResults("results\\Flow-main\\Flow-main.json");
        return "OK";
    }

    public void analyzeRepository(String repoName) throws IOException, InterruptedException {
        log.info("Starting analysis of the repository {}", repoName);

        executeAnalysis("data" + File.separator + repoName + ".zip",
                "data" + File.separator + repoName + ".xlsx");

        processResults("results" + File.separator + repoName + File.separator + repoName + ".json");
    }

    private List<AnalysisResult> processResults(String resultsPath) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();

        String fullPath = System.getProperty("user.dir")
                + "/volnerability-check-main/" + resultsPath;

        List<AnalysisResult> result;
        try (InputStream inputStream = Files.newInputStream(Paths.get(fullPath))) {
            result = objectMapper.readValue(inputStream, new TypeReference<>() {});
        }

        return result;
    }

    private static String executeAnalysis(String repoPath, String vulnerabilitiesExcelPath) throws IOException, InterruptedException {
        // Project root
        File projectRoot = new File(System.getProperty("user.dir"), "volnerability-check-main");
        File pythonExe = new File(projectRoot, ".venv" + File.separator + "Scripts" + File.separator + "python.exe");
        String venvPython = pythonExe.getAbsolutePath();

        ProcessBuilder pb = new ProcessBuilder(
                venvPython,
                "-m", "src",
                "analyze", repoPath, vulnerabilitiesExcelPath
        );
        pb.directory(projectRoot);
        pb.environment().put("PYTHONUTF8", "1");
        pb.redirectErrorStream(true);

        // Start the process
        Process process = pb.start();

        // Capture output in real-time
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
                System.out.println(line); // Optional: log in real-time
            }
        }

        int exitCode = process.waitFor();
        if (exitCode != 0) {
            throw new RuntimeException("Execution failed with code " + exitCode + "\n" + output);
        }

        return output.toString();
    }

    public void processDirectory(String rootPath) {
        Path rootDir = Paths.get(rootPath);

        if (!Files.exists(rootDir) || !Files.isDirectory(rootDir)) {
            log.error("Ścieżka {} nie istnieje lub nie jest katalogiem.", rootPath);
            return;
        }

        log.info("=== Rozpoczynam proces porządkowania folderów w {} ===", rootPath);

        try (DirectoryStream<Path> stream = Files.newDirectoryStream(rootDir)) {
            for (Path folder : stream) {
                if (Files.isDirectory(folder)) {
                    String folderName = folder.getFileName().toString();

                    // Szukamy folderów w formacie RRRRMM_xxx
                    if (folderName.matches("\\d{6}_.+")) {
                        log.info("Przetwarzam folder: {}", folderName);

                        String prefix = folderName.substring(0, 6);
                        Path targetFolder = rootDir.resolve(prefix + "__");

                        // Tworzymy folder docelowy, jeśli nie istnieje
                        if (!Files.exists(targetFolder)) {
                            Files.createDirectories(targetFolder);
                            log.info("Utworzono folder docelowy: {}", targetFolder);
                        }

                        boolean allCopiedOrSkipped = true;

                        try (DirectoryStream<Path> files = Files.newDirectoryStream(folder)) {
                            for (Path file : files) {
                                if (Files.isRegularFile(file)) {
                                    Path targetFile = targetFolder.resolve(file.getFileName());

                                    if (Files.exists(targetFile)) {
                                        log.info("Plik {} już istnieje w {}, pomijam.", file.getFileName(), targetFolder);
                                    } else {
                                        try {
                                            Files.copy(file, targetFile, StandardCopyOption.COPY_ATTRIBUTES);
                                            log.info("Skopiowano plik {} → {}", file.getFileName(), targetFolder);
                                        } catch (IOException e) {
                                            log.error("Błąd podczas kopiowania pliku {}: {}", file, e.getMessage());
                                            allCopiedOrSkipped = false;
                                        }
                                    }
                                }
                            }
                        }

                        // Usuwamy folder tylko jeśli wszystko poszło dobrze
                        if (allCopiedOrSkipped) {
                            try {
                                Files.walkFileTree(folder, new SimpleFileVisitor<>() {
                                    @Override
                                    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                                        Files.delete(file);
                                        return FileVisitResult.CONTINUE;
                                    }

                                    @Override
                                    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                                        Files.delete(dir);
                                        return FileVisitResult.CONTINUE;
                                    }
                                });
                                log.info("Usunięto folder źródłowy: {}", folder);
                            } catch (IOException e) {
                                log.error("Nie udało się usunąć folderu {}: {}", folder, e.getMessage());
                            }
                        } else {
                            log.warn("Folder {} nie został usunięty, ponieważ nie wszystkie pliki udało się skopiować.", folder);
                        }
                    }
                }
            }
        } catch (IOException e) {
            log.error("Błąd podczas przetwarzania folderów w {}: {}", rootPath, e.getMessage());
        }

        log.info("=== Zakończono proces porządkowania folderów ===");
    }
}
