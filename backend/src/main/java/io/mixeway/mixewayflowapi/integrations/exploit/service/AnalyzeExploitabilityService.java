package io.mixeway.mixewayflowapi.integrations.exploit.service;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.mixeway.mixewayflowapi.db.entity.Finding;
import io.mixeway.mixewayflowapi.domain.finding.UpdateFindingService;
import io.mixeway.mixewayflowapi.integrations.exploit.model.AnalysisResult;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Log4j2
@RequiredArgsConstructor
public class AnalyzeExploitabilityService {

    private final UpdateFindingService updateFindingService;

    public void analyzeRepository(String repoName, List<Finding> findings) throws IOException, InterruptedException {
        log.info("Starting analysis of the repository {}", repoName);

        executeAnalysis("data" + File.separator + repoName + ".zip",
                "data" + File.separator + repoName + ".xlsx");

        log.info("Analysis completed successfully. Starting of the result save");
        processResults("results" + File.separator + repoName + File.separator + repoName + ".json", findings);

        log.info("Results saved correctly. Analysis completed for the repository {}", repoName);
    }

    private void processResults(String resultsPath, List<Finding> findings) throws IOException {
        ObjectMapper objectMapper = new ObjectMapper();

        String fullPath = System.getProperty("user.dir")
                + "/volnerability-check-main/" + resultsPath;

        List<AnalysisResult> results;
        try (InputStream inputStream = Files.newInputStream(Paths.get(fullPath))) {
            results = objectMapper.readValue(inputStream, new TypeReference<>() {});
        }

        for (AnalysisResult result : results) {
            Finding analyzedFinding = findings.stream().filter(finding -> {
                assert finding.getVulnerability() != null;
                return finding.getVulnerability().getName().equals(result.getVulnerability_name());
            }).toList().getFirst();

            analyzedFinding.setConfidence(result.getConfidence());
            analyzedFinding.setDetectedMitigations(String.join("; ", result.getMitigations_detected()));
            analyzedFinding.setSuggestedNextSteps(result.getSuggested_next_steps());
            analyzedFinding.setPredictedProbability(result.getPredicted_probability());
            analyzedFinding.setPredictedExploitable(result.getPredicted_exploitable());
        }

        updateFindingService.updateFindings(findings);
    }

    private static String executeAnalysis(String repoPath, String vulnerabilitiesExcelPath) throws IOException, InterruptedException {
        // Project root
        File projectRoot = new File(System.getProperty("user.dir"), "volnerability-check-main");

        // Detect OS â†’ choose correct venv Python path
        String osName = System.getProperty("os.name").toLowerCase();
        String venvPython = getPython(osName, projectRoot);

        ProcessBuilder pb = new ProcessBuilder(
                venvPython,
                "-m", "src",
                "analyze", repoPath, vulnerabilitiesExcelPath
        );
        pb.directory(projectRoot);
        pb.environment().put("PYTHONUTF8", "1");
        pb.redirectErrorStream(true);

        // Start the process
        Process process = pb.start();

        // Capture output in real-time
        StringBuilder output = new StringBuilder();
        try (BufferedReader reader = new BufferedReader(
                new InputStreamReader(process.getInputStream()))) {
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
                System.out.println(line); // Optional: log in real-time
            }
        }

        int exitCode = process.waitFor();
        if (exitCode != 0) {
            throw new RuntimeException("Execution failed with code " + exitCode + "\n" + output);
        }

        return output.toString();
    }

    private static String getPython(String osName, File projectRoot) {
        String pythonRelative;
        if (osName.contains("win")) {
            pythonRelative = ".venv" + File.separator + "Scripts" + File.separator + "python.exe";
        } else {
            pythonRelative = ".venv" + File.separator + "bin" + File.separator + "python";
        }

        File pythonExe = new File(projectRoot, pythonRelative);
        String venvPython = pythonExe.getAbsolutePath();

        if (!pythonExe.exists()) {
            throw new IllegalStateException("Python executable not found: " + venvPython);
        }
        return venvPython;
    }
}
