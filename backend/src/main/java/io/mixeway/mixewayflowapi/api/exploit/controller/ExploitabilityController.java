package io.mixeway.mixewayflowapi.api.exploit.controller;

import io.mixeway.mixewayflowapi.api.exploit.utils.ExploitabilityAnalysisStatus;
import io.mixeway.mixewayflowapi.db.entity.CodeRepo;
import io.mixeway.mixewayflowapi.db.entity.Finding;
import io.mixeway.mixewayflowapi.db.entity.Vulnerability;
import io.mixeway.mixewayflowapi.domain.coderepo.FindCodeRepoService;
import io.mixeway.mixewayflowapi.domain.finding.FindFindingService;
import io.mixeway.mixewayflowapi.exceptions.GitException;
import io.mixeway.mixewayflowapi.integrations.exploit.service.AnalyzeExploitabilityService;
import io.mixeway.mixewayflowapi.scanmanager.service.ScanManagerService;
import io.mixeway.mixewayflowapi.utils.ExcelService;
import io.mixeway.mixewayflowapi.utils.ZipService;
import jakarta.transaction.Transactional;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.io.FileUtils;
import org.hibernate.LazyInitializationException;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.NoSuchElementException;

@RestController
@RequiredArgsConstructor
@Log4j2
public class ExploitabilityController {

    private final FindCodeRepoService findCodeRepoService;
    private final ScanManagerService scanManagerService;
    private final FindFindingService findFindingService;
    private final AnalyzeExploitabilityService analyzeExploitabilityService;

    @GetMapping(value= "/api/v1/exploitability/analyzeRepository")
    public SseEmitter analyzeRepository(@RequestParam long repoId){
        SseEmitter emitter = new SseEmitter(1 * 60 * 1000L);

        CodeRepo codeRepo = findCodeRepoService.findById(repoId).orElseThrow();
        List<Finding> findings = findFindingService.getCodeRepoFindings(codeRepo, codeRepo.getDefaultBranch());
        List<Vulnerability> vulnerabilities = findings.stream().map(Finding::getVulnerability).toList();

        new Thread(() -> {
            try {
                log.info("Starting preparation for analysis of the repository id: {}", repoId);
                emitter.send(SseEmitter.event().name(ExploitabilityAnalysisStatus.START.name()).data("Analysis has started"));

                assert codeRepo.getName() != null;
                String repoName = codeRepo.getName().replace("/", "-");
                String repoDirName =    "volnerability-check-main" + File.separator +
                        "data" + File.separator +
                        repoName;

                log.info("Repository found. Downloading repository");
                emitter.send(SseEmitter.event().name(ExploitabilityAnalysisStatus.REPO_FOUND.name()).data("Repository has been found"));

                FileUtils.deleteDirectory(new File(repoDirName));
                scanManagerService.fetchRepository( null,
                                                    codeRepo.getRepourl(),
                                                    codeRepo.getAccessToken(),
                                                    codeRepo.getDefaultBranch(),
                                                    repoDirName);
                ZipService.zipDirectory(new File(repoDirName), new File("volnerability-check-main" + File.separator + "data" + File.separator + repoName + ".zip"));

                log.info("Repository downloaded. Starting preparation of the vulnerability Excel");
                emitter.send(SseEmitter.event().name(ExploitabilityAnalysisStatus.REPO_PREPARED.name()).data("Repository has been prepared"));

                ExcelService.createVulnerabilitySummaryExcel(vulnerabilities, codeRepo.getRepourl(), repoName, "volnerability-check-main" + File.separator + "data");

                log.info("Starting execution of the exploitability analysis");
                emitter.send(SseEmitter.event().name(ExploitabilityAnalysisStatus.DATA_PREPARED.name()).data("Data required for analysis has been prepared"));

                log.info("Starting execution of the exploitability analysis");
                FileUtils.deleteDirectory(new File(repoDirName));
                analyzeExploitabilityService.analyzeRepository(repoName, findings);

                emitter.send(SseEmitter.event().name(ExploitabilityAnalysisStatus.FINISH.name()).data("Analysis has been completed"));

            } catch (NoSuchElementException | InterruptedException | LazyInitializationException e) {
                log.error(e.getMessage());
                try {
                    emitter.send(SseEmitter.event().name(ExploitabilityAnalysisStatus.ERROR.name()).data("Analysis finished with an error"));
                } catch (IOException ex) {
                    log.error("Analysis encountered an error {}", e.getMessage());
                }
                emitter.completeWithError(e);
            } catch (IOException e) {
                log.error("Analysis encountered an error {}", e.getMessage());
            }
        }).start();

        return emitter;
    }
}
