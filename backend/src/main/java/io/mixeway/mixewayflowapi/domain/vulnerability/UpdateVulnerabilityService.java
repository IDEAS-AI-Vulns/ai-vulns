package io.mixeway.mixewayflowapi.domain.vulnerability;

import com.google.genai.errors.ClientException;
import com.google.genai.errors.ServerException;
import io.mixeway.mixewayflowapi.api.constraint.service.ConstraintService;
import io.mixeway.mixewayflowapi.api.vulnerabilities.events.UpdateConstraintsAndNistDataForAllVulnerabilitiesEvent;
import io.mixeway.mixewayflowapi.db.entity.Vulnerability;
import io.mixeway.mixewayflowapi.db.entity.VulnerableConfigurations;
import io.mixeway.mixewayflowapi.db.repository.VulnerabilityRepository;
import io.mixeway.mixewayflowapi.domain.vulnerability.event.VulnerabilityEvent;
import io.mixeway.mixewayflowapi.domain.vulnerableconfigurations.VulnerableConfigurationsService;
import io.mixeway.mixewayflowapi.exceptions.VulnerabilityException;
import io.mixeway.mixewayflowapi.exceptions.VulnerabilityUpdateRunningException;
import io.mixeway.mixewayflowapi.integrations.gemini.service.GeminiVulnerabilityService;
import io.mixeway.mixewayflowapi.integrations.nist.dto.*;
import io.mixeway.mixewayflowapi.integrations.nist.service.NistService;
import lombok.Getter;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;


/**
 * Service class responsible for updating the details of a {@link Vulnerability}.
 * This service allows patching (partial update) of a vulnerability's description, reference, and recommendation.
 */
@Service
@RequiredArgsConstructor
@Log4j2
public class UpdateVulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;

    private final VulnerableConfigurationsService vulnerableConfigurationsService;
    private final ConstraintService constraintService;
    private final FindVulnerabilityService findVulnerabilityService;

    @Getter private boolean isFullUpdateRunning;
    private final NistService nistService;
    private final GeminiVulnerabilityService geminiVulnerabilityService;

    /**
     * Updates the specified fields of a {@link Vulnerability} entity.
     *
     * @param id The ID of the vulnerability to update.
     * @param description The new description for the vulnerability.
     * @param ref The new reference for the vulnerability.
     * @param recommendation The new recommendation for the vulnerability.
     * @throws VulnerabilityException if the vulnerability with the given ID does not exist.
     */
    public void patch(Long id, String description, String ref, String recommendation) {
        // Fetch the vulnerability from the repository, throw an exception if not found
        Vulnerability vulnerability = vulnerabilityRepository.findById(id).orElseThrow();

        // Update the vulnerability's fields
        vulnerability.patch(description, ref, recommendation);

        // Save the updated vulnerability back to the repository
        vulnerabilityRepository.save(vulnerability);

        // Log the update operation
        log.info("[Update Vulnerability] Updating description for {}", vulnerability.getName());
    }

    public void addExploit(Vulnerability vulnerability, String vector){
        vulnerability.updateKevInfos(true);
        vulnerability.updateVector(vector);
        vulnerabilityRepository.save(vulnerability);
        log.info("[Update Vulnerability] Added exploit to {}", vulnerability.getName());
    }

    @Async
    @EventListener
    public void handleVulnerabilityUpdate(VulnerabilityEvent vulnerabilityEvent) {
        log.debug("Updating vulnerability after the INSERT or UPDATE statement, id:{}", vulnerabilityEvent.getVulnerability().getId());

        updateConstraints(vulnerabilityEvent.getVulnerability(), false);
        updateVulnerabilityWithNistData(vulnerabilityEvent.getVulnerability(), false);
    }

    @Async
    @EventListener
    public void handleUpdateConstraintsAndNistDataForAllVulnerabilitiesEvent (UpdateConstraintsAndNistDataForAllVulnerabilitiesEvent event) throws VulnerabilityUpdateRunningException {
        if (!isFullUpdateRunning)
            updateAllVulnerabilities();
        else
            throw new VulnerabilityUpdateRunningException("Update of the vulnerabilities already running");
    }

    @Scheduled(cron = "0 0 4 * * ?")
    public void updateAllVulnerabilities() throws VulnerabilityUpdateRunningException {
        if (!isFullUpdateRunning){
            log.debug("Updating data for all vulnerabilities");

            isFullUpdateRunning = true;

            updateConstraintsForAllVulnerabilities(false);
            updateNistDataForAllVulnerabilities(false);

            isFullUpdateRunning = false;
        } else
            throw new VulnerabilityUpdateRunningException("Update of the vulnerabilities already running");
    }

    public void updateVulnerabilityById(long id) {
        log.debug("Updating data for all vulnerabilities");

        Vulnerability vulnerability = findVulnerabilityService.getById(id).orElseThrow();

        updateConstraints(vulnerability, false);
        updateVulnerabilityWithNistData(vulnerability, false);
    }

    public void updateConstraintsForAllVulnerabilities(boolean force) {
        List<Vulnerability> vulnerabilitiesToBeUpdated;
        if(!force) {
            vulnerabilitiesToBeUpdated = findVulnerabilityService   .getAll()
                                                                    .stream()
                                                                    .filter(e -> e.getConstraints().isEmpty())
                                                                    .toList();
        } else {
            vulnerabilitiesToBeUpdated = findVulnerabilityService.getAll();
        }

        log.debug("Vulnerabilities that left to be updated: {}", vulnerabilitiesToBeUpdated.size());
        vulnerabilitiesToBeUpdated.forEach(v -> updateConstraints(v, force));
    }

    private void updateConstraints(Vulnerability vulnerability, boolean force) {
        if(!force && !vulnerability.getConstraints().isEmpty()) {
            //log.debug("Vulnerability has constraints already defined, skipping.");
            return;
        }

        log.debug("Updating constraints for the vulnerability id:{}", vulnerability.getId());
        String vulnerabilityDescription =
                "Name: " + vulnerability.getName() + "; Description: " + vulnerability.getDescription();

        try {
            List<String> constraints = geminiVulnerabilityService.analyzeVulnerability(vulnerabilityDescription);
            constraints.forEach(c -> constraintService.createConstraint(vulnerability.getId(), c));
        } catch (ClientException | InterruptedException | ServerException e) {
            log.error("Error occurred while processing: {}", e.getLocalizedMessage());
        }
    }

    public void updateNistDataForAllVulnerabilities(boolean force) {
        List<Vulnerability> vulnerabilitiesToBeUpdated;
        if(!force) {
            vulnerabilitiesToBeUpdated = findVulnerabilityService.getAll()
                                            .stream()
                                            .filter(e -> e.getName().startsWith("CVE") && (e.getConfigurations().isEmpty() || e.getWeaknesses() == null))
                                            .toList();
        } else {
            vulnerabilitiesToBeUpdated = findVulnerabilityService.getAll();
        }

        log.debug("Vulnerabilities that left to be updated with NIST data: {}", vulnerabilitiesToBeUpdated.size());
        vulnerabilitiesToBeUpdated.forEach(v -> updateVulnerabilityWithNistData(v, force));
    }

    public void updateVulnerabilityWithNistData(Vulnerability vulnerability, boolean force) {
        if(!vulnerability.getName().startsWith("CVE")) {
            //log.debug("Vulnerability is not CVE - NIST data cannot be found");
            return;
        }

        if(!force && (vulnerability.getWeaknesses() != null || !vulnerability.getConfigurations().isEmpty())) {
            //log.debug("Vulnerability {} already has NIST data. Skipping its NIST processing", vulnerability.getId());
            return;
        }

        log.debug("Updating NIST data for vulnerability id: {}", vulnerability.getId());
        vulnerability.setUpdatedDate(LocalDateTime.now());
        NistCveDTO nistCveDTO = nistService.getNistDataForVulnerabilityByName(vulnerability.getName());

        if (nistCveDTO == null) {
            log.error("NIST Service has returned null for vulnerability: {}", vulnerability.getName());
            return;
        }
        if (nistCveDTO.getPublished() != null)
            vulnerability.setPublishedDate(LocalDateTime.parse(nistCveDTO.getPublished()));

        if (nistCveDTO.getLastModified() != null)
            vulnerability.setNistLastModifiedDate(LocalDateTime.parse(nistCveDTO.getLastModified()));

        vulnerability.setWeaknesses(getWeaknesses(nistCveDTO));

        List<NistCveCpeMatch> cpeMatches = Optional .ofNullable(nistCveDTO.getConfigurations())
                                                    .orElse(Collections.emptyList())
                                                    .stream()
                                                    .filter(Objects::nonNull)
                                                    .map(NistCveConfiguration::getNodes)
                                                    .filter(Objects::nonNull)
                                                    .flatMap(List::stream)
                                                    .filter(Objects::nonNull)
                                                    .map(NistCveNode::getCpeMatch)
                                                    .filter(Objects::nonNull)
                                                    .flatMap(List::stream)
                                                    .toList();

        if (!cpeMatches.isEmpty()) {
            for (NistCveCpeMatch cpeMatch : cpeMatches) {
                VulnerableConfigurations vulnerableConfiguration = vulnerableConfigurationsService.createVulnerableConfigurationsForVulnerability(cpeMatch, vulnerability);
                if (vulnerableConfiguration != null)
                    vulnerability.getConfigurations().add(vulnerableConfiguration);
            }
        } else {
            vulnerability.getConfigurations().clear();
        }

        updateVulnerabilityMetrics(vulnerability, nistCveDTO);

        vulnerabilityRepository.save(vulnerability);
    }

    private void updateVulnerabilityMetrics(Vulnerability vulnerability, NistCveDTO nistCveDTO) {
        if (nistCveDTO.getMetrics() != null && nistCveDTO.getMetrics().getCvssMetricV31() != null) {
            NistCveCvssMetricV31 metricV31 = nistCveDTO.getMetrics().getCvssMetricV31().getFirst();
            NistCveCvssData cvssData = metricV31.getCvssData();

            vulnerability.setExploitabilityScore(metricV31.getExploitabilityScore());
            vulnerability.setImpactScore(metricV31.getImpactScore());

            vulnerability.setMetricVersion(cvssData.getVersion());
            vulnerability.setVector(cvssData.getVectorString());

            vulnerability.setAttackVector(cvssData.getAttackVector());
            vulnerability.setAttackComplexity(cvssData.getAttackComplexity());
            vulnerability.setPrivilegesRequired(cvssData.getPrivilegesRequired());
            vulnerability.setUserInteraction(cvssData.getUserInteraction());
            vulnerability.setScope(cvssData.getScope());
            vulnerability.setConfidentialityImpact(cvssData.getConfidentialityImpact());
            vulnerability.setIntegrityImpact(cvssData.getIntegrityImpact());
            vulnerability.setAvailabilityImpact(cvssData.getAvailabilityImpact());
            vulnerability.setBaseScore(cvssData.getBaseScore());
            vulnerability.setBaseSeverity(cvssData.getBaseSeverity());
            vulnerability.setExploitCodeMaturity(cvssData.getExploitCodeMaturity());
            vulnerability.setRemediationLevel(cvssData.getRemediationLevel());
            vulnerability.setReportConfidence(cvssData.getReportConfidence());
            vulnerability.setTemporalScore(cvssData.getTemporalScore());
            vulnerability.setTemporalSeverity(cvssData.getTemporalSeverity());
            vulnerability.setConfidentialityRequirement(cvssData.getConfidentialityRequirement());
            vulnerability.setIntegrityRequirement(cvssData.getIntegrityRequirement());
            vulnerability.setAvailabilityRequirement(cvssData.getAvailabilityRequirement());
            vulnerability.setModifiedAttackVector(cvssData.getModifiedAttackVector());
            vulnerability.setModifiedAttackComplexity(cvssData.getModifiedAttackComplexity());
            vulnerability.setModifiedPrivilegesRequired(cvssData.getModifiedPrivilegesRequired());
            vulnerability.setModifiedUserInteraction(cvssData.getModifiedUserInteraction());
            vulnerability.setModifiedScope(cvssData.getModifiedScope());
            vulnerability.setModifiedConfidentialityImpact(cvssData.getModifiedConfidentialityImpact());
            vulnerability.setModifiedIntegrityImpact(cvssData.getModifiedIntegrityImpact());
            vulnerability.setModifiedAvailabilityImpact(cvssData.getModifiedAvailabilityImpact());
            vulnerability.setEnvironmentalScore(cvssData.getEnvironmentalScore());
            vulnerability.setEnvironmentalSeverity(cvssData.getEnvironmentalSeverity());
        }
    }

    private String getWeaknesses(NistCveDTO nistCveDTO) {
        return Optional.ofNullable(nistCveDTO.getWeaknesses())
                                    .orElse(Collections.emptyList())
                                    .stream()
                                    .filter(Objects::nonNull)
                                    .map(NistCveWeakness::getDescription)
                                    .filter(Objects::nonNull)
                                    .flatMap(List::stream)
                                    .filter(Objects::nonNull)
                                    .map(NistCveDescription::getValue)
                                    .filter(Objects::nonNull)
                                    .distinct()
                                    .collect(Collectors.joining(";"));
    }
}
