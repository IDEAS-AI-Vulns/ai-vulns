package io.mixeway.mixewayflowapi.domain.vulnerability;

import com.google.genai.errors.ClientException;
import com.google.genai.errors.ServerException;
import io.mixeway.mixewayflowapi.api.constraint.service.ConstraintService;
import io.mixeway.mixewayflowapi.db.entity.Vulnerability;
import io.mixeway.mixewayflowapi.db.entity.VulnerableConfigurations;
import io.mixeway.mixewayflowapi.db.repository.VulnerabilityRepository;
import io.mixeway.mixewayflowapi.domain.vulnerableconfigurations.VulnerableConfigurationsService;
import io.mixeway.mixewayflowapi.exceptions.VulnerabilityException;
import io.mixeway.mixewayflowapi.integrations.gemini.service.GeminiVulnerabilityService;
import io.mixeway.mixewayflowapi.integrations.nist.dto.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.log4j.Log4j2;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;


/**
 * Service class responsible for updating the details of a {@link Vulnerability}.
 * This service allows patching (partial update) of a vulnerability's description, reference, and recommendation.
 */
@Service
@RequiredArgsConstructor
@Log4j2
public class UpdateVulnerabilityService {

    private final VulnerabilityRepository vulnerabilityRepository;

    private final VulnerableConfigurationsService vulnerableConfigurationsService;
    private final ConstraintService constraintService;
    private final GeminiVulnerabilityService geminiVulnerabilityService;
    private final FindVulnerabilityService findVulnerabilityService;

    /**
     * Updates the specified fields of a {@link Vulnerability} entity.
     *
     * @param id The ID of the vulnerability to update.
     * @param description The new description for the vulnerability.
     * @param ref The new reference for the vulnerability.
     * @param recommendation The new recommendation for the vulnerability.
     * @throws VulnerabilityException if the vulnerability with the given ID does not exist.
     */
    public void patch(Long id, String description, String ref, String recommendation) {
        // Fetch the vulnerability from the repository, throw an exception if not found
        Vulnerability vulnerability = vulnerabilityRepository.findById(id).orElseThrow();

        // Update the vulnerability's fields
        vulnerability.patch(description, ref, recommendation);

        // Save the updated vulnerability back to the repository
        vulnerabilityRepository.save(vulnerability);

        // Log the update operation
        log.info("[Update Vulnerability] Updating description for {}", vulnerability.getName());
    }

    public void addExploit(Vulnerability vulnerability, String vector){
        vulnerability.updateKevInfos(true);
        vulnerability.updateVector(vector);
        vulnerabilityRepository.save(vulnerability);
        log.info("[Update Vulnerability] Added exploit to {}", vulnerability.getName());
    }

    @Scheduled(fixedDelay = 30 * 60 * 1000, initialDelay = 1 * 10 * 1000)
    public List<Vulnerability> updateAllConstraints() {
        long cnt = findVulnerabilityService.getAll()
                .stream()
                .filter(e -> e.getConstraints().isEmpty())
                        .count();
        log.info("Vulnerabilities that left to be updated: {}", cnt);
        return findVulnerabilityService.getAll()
                                        .stream()
                                        .filter(e -> e.getConstraints().isEmpty())
                                        .map(this::updateConstraint)
                                        .toList();
    }

    public List<Vulnerability> updateConstraintsForVulnerabilityById(long id) {
        return findVulnerabilityService.getById(id)
                .stream()
                .map(this::updateConstraint)
                .toList();
    }

    @Async
    @EventListener
    public void handleVulnerabilityUpdate(VulnerabilityEvent vulnerabilityEvent) {
        log.debug("Updating vulnerability after the INSERT or UPDATE statement, id:{}", vulnerabilityEvent.getVulnerability().getId());
        updateConstraint(vulnerabilityEvent.getVulnerability());
    }

    private Vulnerability updateConstraint(Vulnerability vulnerability) {
        log.debug("Updating constraints for the vulnerability id:{}", vulnerability.getId());

        if(!vulnerability.getConstraints().isEmpty()) {
            log.debug("Vulnerability has constraints already defined, skipping.");
            return vulnerability;
        }

        String vulnerabilityDescription =
                "Name: " + vulnerability.getName() + "; Description: " + vulnerability.getDescription();

        try {
            List<String> constraints = geminiVulnerabilityService.analyzeVulnerability(vulnerabilityDescription);
            constraints.forEach(c -> constraintService.createConstraint(vulnerability.getId(), c));
        } catch (ClientException | InterruptedException | ServerException e) {
            log.error("Error occurred while processing: {}", e.getLocalizedMessage());
        }

        return vulnerability;
    }

    public void updateVulnerabilityWithNistData(Vulnerability vulnerability, NistCveDTO nistCveDTO) {
        vulnerability.setUpdatedDate(LocalDateTime.now());

        if (nistCveDTO.getPublished() != null)
            vulnerability.setPublishedDate(LocalDateTime.parse(nistCveDTO.getPublished()));

        if (nistCveDTO.getLastModified() != null)
            vulnerability.setNistLastModifiedDate(LocalDateTime.parse(nistCveDTO.getLastModified()));

        vulnerability.setWeaknesses(getWeaknesses(nistCveDTO));

        List<NistCveCpeMatch> cpeMatches = Optional .ofNullable(nistCveDTO.getConfigurations())
                                                    .orElse(Collections.emptyList())
                                                    .stream()
                                                    .filter(Objects::nonNull)
                                                    .map(NistCveConfiguration::getNodes)
                                                    .filter(Objects::nonNull)
                                                    .flatMap(List::stream)
                                                    .filter(Objects::nonNull)
                                                    .map(NistCveNode::getCpeMatch)
                                                    .filter(Objects::nonNull)
                                                    .flatMap(List::stream)
                                                    .toList();

        for (NistCveCpeMatch cpeMatch: cpeMatches) {
            VulnerableConfigurations vulnerableConfiguration = vulnerableConfigurationsService.createVulnerableConfigurationsForVulnerability(cpeMatch,vulnerability);
            if (!vulnerability.getConfigurations().contains(vulnerableConfiguration))
                vulnerability.getConfigurations().add(vulnerableConfiguration);
        }

        updateVulnerabilityMetrics(vulnerability, nistCveDTO);

        vulnerabilityRepository.save(vulnerability);
    }

    private void updateVulnerabilityMetrics(Vulnerability vulnerability, NistCveDTO nistCveDTO) {
        if (nistCveDTO.getMetrics() != null && nistCveDTO.getMetrics().getCvssMetricV31() != null) {
            NistCveCvssMetricV31 metricV31 = nistCveDTO.getMetrics().getCvssMetricV31().getFirst();
            NistCveCvssData cvssData = metricV31.getCvssData();

            vulnerability.setExploitabilityScore(metricV31.getExploitabilityScore());
            vulnerability.setImpactScore(metricV31.getImpactScore());

            vulnerability.setMetricVersion(cvssData.getVersion());
            vulnerability.setVector(cvssData.getVectorString());

            vulnerability.setAttackVector(cvssData.getAttackVector());
            vulnerability.setAttackComplexity(cvssData.getAttackComplexity());
            vulnerability.setPrivilegesRequired(cvssData.getPrivilegesRequired());
            vulnerability.setUserInteraction(cvssData.getUserInteraction());
            vulnerability.setScope(cvssData.getScope());
            vulnerability.setConfidentialityImpact(cvssData.getConfidentialityImpact());
            vulnerability.setIntegrityImpact(cvssData.getIntegrityImpact());
            vulnerability.setAvailabilityImpact(cvssData.getAvailabilityImpact());
            vulnerability.setBaseScore(cvssData.getBaseScore());
            vulnerability.setBaseSeverity(cvssData.getBaseSeverity());
            vulnerability.setExploitCodeMaturity(cvssData.getExploitCodeMaturity());
            vulnerability.setRemediationLevel(cvssData.getRemediationLevel());
            vulnerability.setReportConfidence(cvssData.getReportConfidence());
            vulnerability.setTemporalScore(cvssData.getTemporalScore());
            vulnerability.setTemporalSeverity(cvssData.getTemporalSeverity());
            vulnerability.setConfidentialityRequirement(cvssData.getConfidentialityRequirement());
            vulnerability.setIntegrityRequirement(cvssData.getIntegrityRequirement());
            vulnerability.setAvailabilityRequirement(cvssData.getAvailabilityRequirement());
            vulnerability.setModifiedAttackVector(cvssData.getModifiedAttackVector());
            vulnerability.setModifiedAttackComplexity(cvssData.getModifiedAttackComplexity());
            vulnerability.setModifiedPrivilegesRequired(cvssData.getModifiedPrivilegesRequired());
            vulnerability.setModifiedUserInteraction(cvssData.getModifiedUserInteraction());
            vulnerability.setModifiedScope(cvssData.getModifiedScope());
            vulnerability.setModifiedConfidentialityImpact(cvssData.getModifiedConfidentialityImpact());
            vulnerability.setModifiedIntegrityImpact(cvssData.getModifiedIntegrityImpact());
            vulnerability.setModifiedAvailabilityImpact(cvssData.getModifiedAvailabilityImpact());
            vulnerability.setEnvironmentalScore(cvssData.getEnvironmentalScore());
            vulnerability.setEnvironmentalSeverity(cvssData.getEnvironmentalSeverity());
        }
    }

    private static String getWeaknesses(NistCveDTO nistCveDTO) {
        return Optional.ofNullable(nistCveDTO.getWeaknesses())
                                    .orElse(Collections.emptyList())
                                    .stream()
                                    .filter(Objects::nonNull)
                                    .map(NistCveWeakness::getDescription)
                                    .filter(Objects::nonNull)
                                    .flatMap(List::stream)
                                    .filter(Objects::nonNull)
                                    .map(NistCveDescription::getValue)
                                    .filter(Objects::nonNull)
                                    .distinct()
                                    .collect(Collectors.joining(";"));
    }
}
